# Multi-Policy Cache System (C++ 高性能通用缓存系统)

这是一个基于 C++17 开发的轻量级、插件化缓存库。项目实现了从基础的 FIFO 到复杂的自适应算法 ARC 等多种策略，并提供了针对高并发场景的哈希分片优化。通过内置的基准测试工具，可以直观地对比各算法在不同工作负载下的命中率表现。

##  项目特性
- **泛型设计**：支持任意类型的 Key 和 Value。
- **模块化架构**：算法实现与基类解耦，易于扩展。
- **高并发支持**：提供基于分片锁（Sharding）的 Hash-LRU 和 Hash-LFU，降低锁竞争。
- **工业级算法**：包含 LRU-K 和 ARC 等能够有效对抗缓存污染的先进算法。

---

## 📂 目录结构说明

```text
myCacheProject/
├── src/
│   ├── Common/         # 公共基类 (CachePolicy) 与 核心数据结构
│   ├── FIFO/           # 先进先出算法
│   ├── LRU/            # LRU 相关 (包含标准 LRU, LRU-K, Hash-LRU)
│   ├── LFU/            # LFU 相关 (包含标准 LFU, Hash-LFU)
│   ├── ARC/            # 自适应缓存替换算法 (核心模块)
│   └── test.cpp        # 综合基准测试程序
└── CMakeLists.txt      # 自动化构建脚本



📂 算法模块深度解析1. ARC (Adaptive Replacement Cache) —— 智能自适应替换位置：src/ARC/这是本项目的核心，其性能在多数情况下优于传统 LRU。它通过四个链表（$T_1, B_1, T_2, B_2$）实现对数据“新近度”和“频率”的精准平衡。双层过滤架构：$T_1$ (Target 1)：存储最近只访问过一次的数据（LRU 分量）。$T_2$ (Target 2)：存储访问过多次的数据（LFU 分量）。$B_1 / B_2$ (Ghost Lists)：幽灵列表，不存储实际 Value，仅记录已淘汰节点的 Key。自适应反馈控制：算法维护一个目标比例 $p$。当请求命中 $B_1$ 时，说明系统近期“新近数据”流失严重，算法会增大 $p$ 以扩张 $T_1$ 容量；反之命中 $B_2$ 则扩张 $T_2$。代码实现亮点：使用了智能指针引用计数策略，主缓存持有 shared_ptr 保证对象存活，幽灵列表在必要时通过 Key 进行重构，确保了极低的内存开销。2. LRU-K (Least Recently Used K) —— 扫描抗性优化位置：src/LRU/传统 LRU 容易被偶发性的全表扫描“洗掉”真正的热点，LRU-K 通过提高进入门槛解决了这一问题。两级队列设计：History List：记录数据被访问的次数，但还没达到 $K$ 次。Cache List：真正存放热点数据的区域。晋升机制：数据必须在指定时间内被访问满 $K$ 次（本项目默认 $K=2$），才会被视为“热点”从历史队列晋升至缓存队列。技术价值：有效过滤了“仅访问一次”的噪声数据，使缓存命中率在存在大量冷数据扫描的环境下依然保持稳定。3. Hash-Sharding (并发分片锁)位置：src/LRU/ & src/LFU/在多核场景下，全局互斥锁会成为严重的性能瓶颈。本项目引入了分片技术来提升吞吐量。锁粒度降低：将一个大的缓存逻辑拆分为 $N$ 个独立的分片（Slice）。通过 std::hash<Key> % SliceNum 将请求路由到特定分片。无竞争设计：不同分片之间完全并行，互不干扰。在高并发读写下，由于锁竞争（Lock Contention）导致的 CPU 等待时间降低了约 $N$ 倍。硬件适配：代码自动调用 std::thread::hardware_concurrency() 获取 CPU 核心数，动态决定最适分片配置。4. LFU (Least Frequently Used) —— 频率感知的 O(1) 实现位置：src/LFU/基于访问频率淘汰数据，适合长期热点明显的场景。高效数据结构：结合了 unordered_map（哈希索引）和 map<Frequency, list<Node>>（频率桶）。通过维护一个全局最小频率指针 minFreq，实现了在 $O(1)$ 时间内定位并淘汰频率最低的节点。动态老化 (Aging) 机制：为了防止某些数据在早期被大量访问后“永久占据”缓存（即使后期已无人问津），本项目实现了频率缩减功能。当平均访问频率超过阈值时，自动衰减全局计数，赋予新数据晋升机会。5. 基础设施与内存安全 (Common)位置：src/Common/接口抽象：CachePolicy 基类定义了统一的 put 和 get 虚接口，利用 C++ 多态实现了测试套件对不同算法的无缝切换。智能指针防泄漏：在 ArcCacheNode 的双向链表实现中，巧妙使用了 std::weak_ptr (前驱) 和 std::shared_ptr (后继)。技术细节：如果前后指针都使用 shared_ptr，会导致循环引用，即使外部销毁了缓存，内存也无法释放。本项目的方案彻底杜绝了这一隐患。
